type chan struct {
  mx sync.mutex
  buffer []T
  readers []Goroutines
  writers []Goroutines
}

I. Nil channel
    1. Создание
    2. len и cap
    3. Запись/получение значения: <-
    4. Закрытие канала: close

II. Unbuffered channel
    1. Создание
    2. len и cap
    3. Запись/получение значения: <-

  unbufferedChannel {
    len(buffer) = 0 //unused
    readers []Goroutines
    writers []Goroutines
  }

    4. Направленность канала: make(<-chan int) make(chan<- int)
    5. Закрытие канала: close. Всегда закрывать отправителем

III. Buffered channel
    1. Создание
    2. len и cap
    3. Запись/получение значения: <-

bufferedChannel {
    len(buffer) > 0;   []
    readers []Goroutines
    writers []Goroutines
  }

    4. Закрытие канала: close. Всегда закрывать отправителем

IV: Проверка на закрытие
V: For..range


p.s:
  Deadlock (взаимная блокировка) — это ситуация в многопоточном программировании, 
    при которой два или более потока находятся в состоянии бесконечного ожидания ресурсов, 
    удерживаемых друг другом, и ни один из них не может продолжить выполнение.

  Небуферизированный канал (unbuffered channel) в Go — это канал, который не имеет внутреннего буфера для хранения значений. 
    Это означает, что отправка (send) и получение (receive) значений через такой канал блокируют выполнение до тех пор, 
    пока отправитель и получатель не будут готовы.

Основные характеристики небуферизированного канала:
  Синхронность: Отправка значения в небуферизированный канал блокирует выполнение отправителя до тех пор, 
    пока другой поток не выполнит операцию получения (receive) из этого канала. Аналогично, операция получения 
    блокирует выполнение до тех пор, пока другой поток не выполнит операцию отправки (send).
  Гарантия доставки: Небуферизированные каналы гарантируют, что отправленное значение будет получено другим 
    потоком. Это делает их полезными для синхронизации и передачи данных между потоками с гарантией доставки


Горутина (goroutine) и канал (channel) — это ключевые элементы параллелизма и синхронизации в языке программирования Go. 
  Они используются для организации асинхронного и параллельного выполнения кода, а также для обмена данными между потоками выполнения. 
  Вот основные различия между ними:
    Горутина (Goroutine)
      Понятие: Горутина — это легковесный поток выполнения, который управляется средой выполнения Go (runtime). 
        Горутины позволяют запускать функции или методы асинхронно.
      Создание: Горутина создается с помощью ключевого слова go перед вызовом функции или метода. Например: go myFunction().
      Использование: Горутины используются для параллельного выполнения задач. Они позволяют программе выполнять несколько 
        операций одновременно, что улучшает производительность и отзывчивость приложения.
      Управление: Горутины управляются средой выполнения Go и автоматически планируются на доступных процессорах. Разработчик 
        не управляет жизненным циклом горутин напрямую, за исключением запуска и завершения.

      Канал (Channel)
        Понятие: Канал — это механизм для обмена данными между горутинами. Он обеспечивает безопасный способ передачи 
          значений от одной горутины к другой.
        Создание: Канал создается с помощью функции make. Например: ch := make(chan int).
        Использование: Каналы используются для синхронизации и передачи данных между горутинами. Они позволяют горутинам 
          обмениваться информацией без явного использования мьютексов или других примитивов синхронизации.
        Операции: Основные операции с каналами — это отправка (ch <- value) и получение (value := <-ch). Эти операции 
          могут блокировать выполнение горутины, если канал не готов к отправке или получению данных.


Merge каналов

package main

import (
	"fmt"
	"time"
)

// mergeChannels объединяет значения из нескольких каналов в один канал
func mergeChannels(channels ...<-chan int) <-chan int {
	mergedChan := make(chan int)

	// Функция для чтения из одного канала и отправки значений в mergedChan
	fanIn := func(ch <-chan int) {
		for val := range ch {
			mergedChan <- val
		}
	}

	// Запускаем горутины для каждого канала
	for _, ch := range channels {
		go fanIn(ch)
	}

	return mergedChan
}

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)

	// Запускаем горутины для отправки значений в каналы
	go func() {
		for i := 1; i <= 5; i++ {
			ch1 <- i
			time.Sleep(time.Millisecond * 500)
		}
		close(ch1)
	}()

	go func() {
		for i := 6; i <= 10; i++ {
			ch2 <- i
			time.Sleep(time.Millisecond * 300)
		}
		close(ch2)
	}()

	// Объединяем каналы
	mergedChan := mergeChannels(ch1, ch2)

	// Читаем значения из объединенного канала
	for val := range mergedChan {
		fmt.Println(val)
	}
}